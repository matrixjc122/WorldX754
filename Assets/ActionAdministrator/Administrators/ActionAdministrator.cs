//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using RuleAdministration.Interfaces;
using System.Collections.Generic;
using UnityEngine;
using RuleAdministration.Rules;

namespace RuleAdministration.Administrators
{       
	/// <summary>
	/// Coral rule administrator.
	/// </summary>
	public class ActionAdministrator : IRuleAdministrator
	{


			
		private static ActionAdministrator _instance = new ActionAdministrator ();
		private Dictionary<string, Dictionary<string,IAction> > _AssociatedRules;
		public IErrorMessage _ErrorMessage = new ErrorMessage ();
			

		/// <summary>
		/// Gets the instance.
		/// </summary>
		/// <value>The instance.</value>
		public static ActionAdministrator Instance {
			get {
				if (_instance == null) {
					_instance = new ActionAdministrator ();
				}
				return _instance;
			}
		}

//				public void RegisterRule (string type, IAction rule)
//				{
//						if (_AssociatedRules == null)
//								_AssociatedRules = new Dictionary<string , Dictionary<string,IAction> > ();
//						if (!_AssociatedRules.ContainsKey (type))
//								_AssociatedRules.Add (type, new Dictionary<string, IAction> ()); 
//						_AssociatedRules [type].Add (rule.Name(), rule);
//				}
//
//		#region IRuleAdministrator implementation
//
//		public void ApplyTriggerActionGlobal<T> () where T : new()
//		{
//			throw new NotImplementedException ();
//		}
//
//		public void ApplyTriggerActionGlobal (IRepeatableAction action)
//		{
//			for(int x = 0 ; x < worldXSingelton.WorldObjects.GetLength(0); x++)
//			{
//				for(int y = 0 ; y < worldXSingelton.WorldObjects.GetLength(1); y++)
//				{
//					this.ApplyAction(worldXSingelton.WorldObjects[x,y], action);
//				}	
//			}
//		}

//		#endregion


			
		private ActionAdministrator ()
			:base()
		{
		}

		public void ApplyAction<SelectorType, ActionType> (params TileAccessor[] list) where SelectorType:new() where ActionType:new()
		{
			ApplyAction (new SelectorType () as ISelector, new ActionType () as IAction, list);
		}
		
		public void ApplyAction<ActionType> (ISelector selector, params TileAccessor[] list) where ActionType:new()
		{
			ApplyAction (selector, new ActionType () as IAction, list);
		}
			
		public void ApplyAction (ISelector selector, IAction action, params TileAccessor[] objects)
		{
			// Create Random Selector
			ApplyAction (action, selector.GetSelectedObjects ());
		}
	
		public void ApplyAction (IAction action, params TileAccessor[] list)
		{

			foreach (TileAccessor tile in list) {
				action.Tile = tile;
				
				if (action.IsApplicable () == true) {
					action.BeforeUpdate ();
					action.Update ();
					action.AfterUpdate ();
					
					//--------------------------------
					Debug.Log (action.Name () + " Processed");
					//--------------------------------
					
				} else {
					//--------------------------------
					Debug.Log (action.Name () + " is not applicable!");
					//--------------------------------
					
				}	
			}
		}
				
		public void ApplyAction<T> (params TileAccessor[] current) where T:new()
		{
			ApplyAction (new T () as IAction, current);
		}
		
		public void ApplyActionAtNeighbors<T> (Vector2 center_pos, bool[,] Neighborhood) where T:new()
		{
			for (int x =0; x < Neighborhood.GetLength(0); x++) {
				for (int y =0; y < Neighborhood.GetLength(1); y++) {
					if (Neighborhood [x, y] == true) {
						int width = worldXSingelton.Layer2Objects.GetLength (0);
						int height = worldXSingelton.Layer2Objects.GetLength (1);
						int world_width = worldXSingelton.Layer2Objects.GetLength (0);
						int world_height = worldXSingelton.Layer2Objects.GetLength (1);
						
						//go to upper left corner of the mask array relative to current pos_self
						Vector2 pos_local = center_pos + new Vector2 (-1, -1);
						
						pos_local.x += x;
						pos_local.y += y;
						
						
						if (pos_local.x < 0) {
							//						Debug.Log(pos_ul.x + x);
							continue;
						}
						if (pos_local.x >= width && pos_local.x >= world_width) {
							//						Debug.Log(pos_ul.x + x);
							continue;
						}
						if (pos_local.y < 0) {
							//						Debug.Log(pos_ul.y + y);
							continue;
						}
						if (pos_local.y >= height && pos_local.y >= world_height) {
							//						Debug.Log(pos_ul.y + y);
							continue;
						}
						
						ApplyAction (new T () as IAction, new TileAccessor (new Vector2 ((int)pos_local.x, (int)pos_local.y)));
					}
				}			
			}
		}
				
	}
}

